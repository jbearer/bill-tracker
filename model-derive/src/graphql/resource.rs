//! Derive macro for the `Resource` trait.

use super::graphql_path;
use crate::helpers::{parse_docs, AttrParser};
use convert_case::{Case, Casing};
use itertools::{Either, Itertools};
use proc_macro2::{Span, TokenStream};
use quote::{format_ident, quote};
use syn::{
    Attribute, Data, DataStruct, DeriveInput, Expr, Field, Fields, Ident, LitBool, Type, Visibility,
};

/// Derive a `Resource` instance for a struct.
pub fn derive(
    DeriveInput {
        vis,
        ident,
        generics,
        data,
        attrs,
    }: DeriveInput,
) -> TokenStream {
    if !generics.params.is_empty() {
        panic!("Resource cannot be derived on generic types");
    }
    match data {
        Data::Struct(s) => generate_struct(s, vis, ident, attrs),
        _ => panic!("Resource can only be derived for structs"),
    }
}

fn generate_struct(
    s: DataStruct,
    vis: Visibility,
    name: Ident,
    attrs: Vec<Attribute>,
) -> TokenStream {
    let graphql = graphql_path();
    let p = AttrParser::new("resource");
    let name_str = name.to_string();

    // The visibiltiy of exported fields in the macro generated by this module.
    let export: Visibility = syn::parse2(match &vis {
        // If the original struct is private to its scope, export the generated items to that scope
        // but no farther.
        Visibility::Inherited => quote!(pub(super)),
        // Otherwise use the explicity visibility from the original struct.
        _ => quote!(#vis),
    })
    .unwrap();

    // Get fields, filtering out skipped ones.
    let Fields::Named(fields) = s.fields else {
        panic!("Resource fields must be named");
    };
    let (skipped, fields): (Vec<_>, Vec<_>) = fields.named.into_iter().partition_map(|f| {
        if let Some(default) = skipped_field_default(&p, &f) {
            Either::Left((f, default))
        } else {
            Either::Right(f)
        }
    });

    // Get the plural name for this struct. If it is given explicitly via the `plural` attribute we
    // will use that; otherwise just add an `s`.
    let plural_name = p
        .get_arg(&attrs, "plural")
        .unwrap_or_else(|| format_ident!("{}s", name));
    let plural_name_str = plural_name.to_string();

    // Derive a name for the module that will contain the generated items;
    let mod_name = p
        .get_arg(&attrs, "module")
        .unwrap_or_else(|| Ident::new(&name.to_string().to_case(Case::Snake), Span::call_site()));

    // Get the documentation on this struct. We will need to add this to the generated `#[Object]`
    // impl so that it shows up in the exported schema.
    let doc = parse_docs(&attrs);

    // Derive names for the various predicate structs we are going to create.
    let pred_name = format_ident!("{}Predicate", name);
    let has_name = format_ident!("{}Has", name);
    let plural_pred_name = format_ident!("{}Predicate", plural_name);
    let quant_name = format_ident!("Quantified{}Predicate", name);

    // Create documentation for each of the predicate structs.
    let has_doc = format!("A predicate on fields of {}.", name);
    let pred_doc = format!("A predicate used to filter {}.", plural_name);
    let quant_doc = format!(
        "A predicate which must match a certain quantity of {}.",
        plural_name
    );
    let plural_pred_doc = format!("A predicate used to filter collections of {}.", plural_name);

    // Generate marker types to hold metadta for each field.
    let field_metas = fields
        .iter()
        .map(|f| generate_field_meta(&export, &name, f));
    let field_meta_impls = fields
        .iter()
        .map(|f| generate_field_meta_impl(&p, &name, f));

    // Generate code to reconstruct each field from a builder.
    let field_builders = fields.iter().map(|f| generate_field_builder(&p, f));

    // Generate code to populate skipped fields with default values during building.
    let skipped_field_builders = skipped.iter().map(|(f, default)| {
        let name = f.ident.as_ref().expect("Resource fields must be named");
        quote!(#name: #default,)
    });

    // Generate predicates for each field of this struct.
    let pred_fields = fields.iter().map(|f| generate_predicate_field(&p, f));

    // Generate builder methods for each field of this struct.
    let has_builder_fields = fields
        .iter()
        .map(|f| generate_has_builder_field(&p, &export, f));

    // Generate statements that compile each of the has fields into a predicate compiler.
    let has_compilers = fields.iter().map(|f| generate_has_compiler(&p, f));

    // If this struct has a _primary field_, it gets a couple of extra predicate options. In
    // addition to filtering by applying a predicate to its fields, you can implicitly filter based
    // on the primary field, which leads to shorter, more readable queries. In particular, you can
    // say, e.g. `state CA` instead of `state with abbreviation CA`.
    let primary_field = fields.iter().find(|f| p.has_bool(&f.attrs, "primary"));
    // The `is` predicate based on the primary field.
    let is_primary = primary_field.as_ref().map(|f| {
        let ty = &f.ty;
        quote! {
            /// Filter by value.
            Is(<#ty as Type>::Predicate),
        }
    });
    // Compile the `is` predicate.
    let is_primary_compiler = primary_field.as_ref().map(|_| {
        quote! {
            Self::Is(value) => unimplemented!("Is predicates"),
        }
    });
    // The `includes` plural predicate, filtering a collection based on whether or not it contains
    // any items with the given value for their primary field.
    let includes_primary = primary_field.as_ref().map(|f| {
        let ty = &f.ty;
        quote! {
            /// Matches if the collection includes the specified value.
            Includes(Value<#ty>),
        }
    });

    // Generate resolvers for each field.
    let resolvers = fields.iter().map(|f| generate_resolver(&p, f));

    quote! {
        #vis mod #mod_name {
            // We currently generate some `unimplemented!()` calls in some of the generated items.
            // This causes warnings in reachability analysis since the `unimplemented!()` macro
            // unconditionally panics. Until we finish this derive macro and remove all the calls to
            // `unimplemented!()`, ignore these warnings in the generated code.
            #![allow(unreachable_code)]

            use super::*;
            use #graphql::{
                async_graphql, connection::Connection, backend::{Cursor, DataSource, Many},
                type_system::{
                    Builder, BuildError, Field, PluralField, PluralPredicate,
                    PluralPredicateCompiler, PluralType, Predicate, PredicateCompiler, Resource,
                    ResourceBuilder, ResourcePredicate, ResourcePredicateCompiler, Type, Value,
                },
                Context, D, EmptyFields, InputObject, Object, OneofObject, Result,
            };

            #[doc = #doc]
            #[Object]
            impl #name {
                #(#resolvers)*
            }

            // The field metas are the only types generated here which can't be accessed through a
            // projection of the original type. (Contrast with, e.g., `<#name as Type>::Predicate`
            // to unambiguously reference the predicate type.) To prevent their names from colliding
            // with the names of other resources, we generate them in a nested module.
            #[doc = "Metadata about fields of "]
            #[doc = #name_str]
            #export mod fields {
                #(#field_metas)*
            }
            #(#field_meta_impls)*

            #[doc = #has_doc]
            #[derive(Clone, Debug, Default, InputObject)]
            #export struct #has_name {
                #(#pred_fields)*
            }

            impl #has_name {
                #(#has_builder_fields)*

                /// Compile this predicate into a form the backend can execute.
                #export fn compile<C: ResourcePredicateCompiler<#name>>(
                    self,
                    mut compiler: C,
                ) -> C::Result {
                    #(#has_compilers)*
                    compiler.end()
                }
            }

            #[doc = #pred_doc]
            #[derive(Clone, Debug, OneofObject)]
            #export enum #pred_name {
                /// Filter by fields.
                Has(Box<#has_name>),
                #is_primary
            }

            impl From<#has_name> for #pred_name {
                fn from(has: #has_name) -> Self {
                    Self::Has(Box::new(has))
                }
            }

            impl Predicate<#name> for #pred_name {
                fn compile<C: PredicateCompiler<#name>>(self, compiler: C) -> C::Result {
                    self.compile_resource_predicate(compiler.resource())
                }
            }

            impl ResourcePredicate<#name> for #pred_name {
                fn compile_resource_predicate<C: ResourcePredicateCompiler<#name>>(
                    self,
                    compiler: C,
                ) -> C::Result {
                    match self {
                        Self::Has(has) => has.compile(compiler),
                        #is_primary_compiler
                    }
                }
            }

            #[doc = #quant_doc]
            #[derive(Clone, Debug, InputObject)]
            #export struct #quant_name {
                /// The minimum or maximum number of items which must match.
                quantity: usize,
                /// The predicate to match against specific items.
                predicate: #pred_name,
            }

            #[doc = #plural_pred_doc]
            #[derive(Clone, Debug, OneofObject)]
            #export enum #plural_pred_name {
                /// Matches if at least some number of items in the collection match a predicate.
                AtLeast(#quant_name),
                /// Matches if at most some number of items in the collection match a predicate.
                AtMost(#quant_name),
                /// Matches if at any items in the collection match a predicate.
                Any(#pred_name),
                /// Matches if all items in the collection match a predicate.
                All(#pred_name),
                /// Matches if no items in the collection match a predicate.
                None(#pred_name),
                #includes_primary
            }

            impl PluralPredicate<#name> for #plural_pred_name {
                fn compile<C: PluralPredicateCompiler<#name>>(self, compiler: C) -> C::Result {
                    unimplemented!("plural predicate compilation")
                }
            }

            impl #name {
                /// Filter this resource by its fields.
                #export fn has() -> #has_name {
                    Default::default()
                }
            }

            impl Type for #name {
                type Predicate = #pred_name;
                type PluralPredicate = #plural_pred_name;

                const NAME: &'static str = #name_str;
                const PLURAL_NAME: &'static str = #plural_name_str;

                fn build<B: Builder<Self>>(builder: B) -> Result<Self, B::Error> {
                    Self::build_resource(builder.resource())
                }
            }

            impl Resource for #name {
                type ResourcePredicate = #pred_name;

                fn build_resource<B: ResourceBuilder<Self>>(builder: B) -> Result<Self, B::Error> {
                    Ok(Self {
                        #(#field_builders)*
                        #(#skipped_field_builders)*
                    })
                }
            }
        }
    }
}

fn generate_field_meta(vis: &Visibility, resource: &Ident, f: &Field) -> TokenStream {
    let name = field_meta_name(f.ident.as_ref().expect("Resource fields must be named"));
    let doc = format!("Metadata about the field {resource}::{name}.");
    quote! {
        #[doc = #doc]
        #[derive(Clone, Copy, Debug)]
        #vis struct #name;
    }
}

fn generate_field_meta_impl(p: &AttrParser, resource: &Ident, f: &Field) -> TokenStream {
    let name = field_meta_name(f.ident.as_ref().expect("Resource fields must be named"));
    let name_str = name.to_string();
    let ty = &f.ty;
    if field_is_plural(p, f) {
        quote! {
            impl PluralField for fields::#name {
                type Type = #ty;
                type Resource = #resource;
                const NAME: &'static str = #name_str;
            }
        }
    } else {
        quote! {
            impl Field for fields::#name {
                type Type = #ty;
                type Resource = #resource;
                const NAME: &'static str = #name_str;
            }
        }
    }
}

fn generate_field_builder(p: &AttrParser, f: &Field) -> TokenStream {
    let name = f.ident.as_ref().expect("Resource fields must be named");
    let meta = field_meta_name(name);
    if field_is_plural(p, f) {
        quote! {
            #name: unimplemented!("plural field building"),
        }
    } else {
        quote! {
            #name: builder.field::<fields::#meta>().map_err(B::Error::field::<fields::#meta>)?,
        }
    }
}

fn generate_predicate_field(p: &AttrParser, f: &Field) -> TokenStream {
    let ty = &f.ty;
    let Some(name) = &f.ident else {
        panic!("Resource fields must be named");
    };
    if field_is_plural(p, f) {
        // If the field is plural, it is filtered by a predicate on collections of the singular
        // type.
        quote! {
            #name: Option<<<#ty as PluralType>::Singular as Type>::PluralPredicate>,
        }
    } else {
        // Otherwise it is just filtered by the regular singular predicate.
        quote! {
            #name: Option<<#ty as Type>::Predicate>,
        }
    }
}

fn generate_has_builder_field(p: &AttrParser, vis: &Visibility, f: &Field) -> TokenStream {
    let ty = &f.ty;
    let Some(name) = &f.ident else {
        panic!("Resource fields must be named");
    };
    let doc = format!("Apply a predicate to the field {name}.");
    if field_is_plural(p, f) {
        // If the field is plural, it is filtered by a predicate on collections of the singular
        // type.
        quote! {
            #[doc = #doc]
            #vis fn #name(
                mut self,
                pred: <<#ty as PluralType>::Singular as Type>::PluralPredicate,
            ) -> Self {
                self.#name = Some(pred);
                self
            }
        }
    } else {
        // Otherwise it is just filtered by the regular singular predicate.
        quote! {
            #[doc = #doc]
            #vis fn #name(mut self, pred: <#ty as Type>::Predicate) -> Self {
                self.#name = Some(pred);
                self
            }
        }
    }
}

fn generate_has_compiler(p: &AttrParser, f: &Field) -> TokenStream {
    let name = f.ident.as_ref().expect("Resource fields must be named");
    let meta = field_meta_name(name);
    if field_is_plural(p, f) {
        quote! {
            if let Some(pred) = self.#name {
                compiler = compiler.plural_field::<fields::#meta>(pred);
            }
        }
    } else {
        quote! {
            if let Some(pred) = self.#name {
                compiler = compiler.field::<fields::#meta>(pred);
            }
        }
    }
}

fn generate_resolver(p: &AttrParser, f: &Field) -> TokenStream {
    let name = &f.ident;
    let ty = &f.ty;
    let doc = parse_docs(&f.attrs);

    if field_is_plural(p, f) {
        let singular = quote! { <#ty as PluralType>::Singular };
        quote! {
            // Resolvers that yields collections get extra parameters for filtering the collections,
            // including paging parameters and a where clause.
            #[doc = #doc]
            async fn #name(
                &self,
                ctx: &Context<'_>,
                #[graphql(name = "where")]
                filter: Option<<#singular as Type>::Predicate>,
                after: Option<String>,
                before: Option<String>,
                first: Option<usize>,
                last: Option<usize>,
            ) -> Result<Connection<Cursor<D, #singular>, #singular>> {
                // Use the corresponding field to silence dead code warnings. We can remove this
                // once we have actually implemented this resolver.
                let _ = &self.#name;

                unimplemented!("plural resolvers")
            }
        }
    } else {
        quote! {
            // Singular fields just resolve to the field itself.
            #[doc = #doc]
            async fn #name(&self) -> &#ty {
                &self.#name
            }
        }
    }
}

fn field_is_plural(p: &AttrParser, f: &Field) -> bool {
    // Check if the field is explicitly plural.
    if p.has_bool(&f.attrs, "plural") {
        return true;
    }
    let explicit: Option<LitBool> = p.get_arg(&f.attrs, "plural");
    let explicit = explicit.map(|lit| lit.value);
    if explicit == Some(true) {
        return true;
    }

    // Check if the field has an implicitly plural type (e.g. `Many`). If not, it is not plural.
    let Type::Path(path) = &f.ty else { return false; };
    let Some(type_name) = path.path.segments.last() else { return false; };
    if type_name.ident == "Many" && explicit != Some(false) {
        return true;
    }
    // If the field is not explicitly or implicitly plural, it is not plural.
    false
}

fn skipped_field_default(p: &AttrParser, f: &Field) -> Option<TokenStream> {
    if p.has_bool(&f.attrs, "skip") {
        // The field is skipped with no explicit default. Use the [`Default`] trait.
        Some(quote!(Default::default()))
    } else {
        p.get_arg::<Expr, _>(&f.attrs, "skip").map(|default| {
            // The field is skipped and an explicit default expression is provided.
            quote!(#default)
        })
    }
}

fn field_meta_name(f: &Ident) -> Ident {
    Ident::new(&f.to_string().to_case(Case::Pascal), f.span())
}
